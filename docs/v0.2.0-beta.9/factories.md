---
title: Factories
version: v0.2.0-beta.9

redirect_from: "/docs/latest/factories/"
---

Factories are used to seed your database, either during development or within tests. Whenever you generate an object via a factory, it will automatically get added to the database, and thus get an autogenerated `id`.

You define factories by using the `ember g mirage-factory [name]` command, or creating files under the `mirage/factories` directory. The name of the factory is determined by the filename.

Factories have attributes, and you create objects from factory definitions using the `server.create` and `server.createList` methods.

## Defining factories

Attributes can be static (strings, numbers or booleans) or dynamic (a function). Here's a factory with some static attributes:

```js
// mirage/factories/user.js
import { Factory } from 'ember-cli-mirage';

export default Factory.extend({
  name: 'Link',
  age: 563,
  evil: false,
});
```

Functions receive the sequence number *i* as an argument, which is useful to create dynamic attributes:

```js
// mirage/factories/user.js
import { Factory } from 'ember-cli-mirage';

export default Factory.extend({
  name(i) {
    return 'User ' + i
  }
});
```

The first user generated (per test) would have a name of `User 1`, the second a name of `User 2`, and so on.

Finally, you can also reference attributes from within a dynamic attribute via `this`:

```js
// mirage/factories/contact.js
import { Factory } from 'ember-cli-mirage';

export default Factory.extend({

  age: 18,

  isAdmin(i) {
    return this.age > 30;
  }

});
```

This even works with other dynamic attributes:

```js
// mirage/factories/contact.js
import { Factory } from 'ember-cli-mirage';

export default Factory.extend({

  email(i) {
    return `email${i}@acme.com`;  
  },

  isAdmin(i) {
    return this.email === 'email1@acme.com';
  }

});
```

You'll get an error if you create an invalid cycle of dynamic attributes.

---

You should define the attributes of your factory as the "base case" for your objects, and override them within your tests. We'll discuss how do to this in the Creating Objects section.

## Using Faker.js

The [Faker.js](https://github.com/marak/Faker.js/) library is included with Mirage, and its methods work nicely with factory definitions:

```js
// mirage/factories/user.js
import { Factory, faker} from 'ember-cli-mirage';

export default Factory.extend({
  firstName() {
    return faker.name.firstName();
  },
  lastName() {
    return faker.name.lastName();
  },
  avatar() {
    return faker.internet.avatar();
  }
});
```

We've also added two methods on the `faker` namespace, `list.cycle` and `list.random`, which are useful if you have a set of data you want your factories to iterate through:

```js
// mirage/factories/subject.js
import { Factory, faker } from 'ember-cli-mirage';

export default Factory.extend({
  name(i) {
    return faker.list.cycle('Economics', 'Philosophy', 'English', 'History', 'Mathematics')(i);
  },
  students() {
    return faker.list.random(100, 200, 300, 400, 500)();
  }
});
```

`cycle` loops through the data in order, while `random` chooses a random element from the list each time an object is created.

View [Faker's docs](https://github.com/marak/Faker.js/) for the full faker API.

## Extending factories

You can extend factories:

```js
// mirage/factories/human.js
import { Factory } from 'ember-cli-mirage';

export default Factory.extend({
  species: 'homo sapiens'
});

// mirage/factories/man.js
import Human from './human';

export default Human.extend({
  gender: 'male'
});
```

## Creating objects

Once you've defined a factory for a model, you can generate data for that model using `server.create` and `server.createList`, either from within `mirage/scenarios/default.js` for development, or from within your acceptance tests.

<a name="create" href="#create">#</a> server.<b>create</b>(<i>type</i> [, <i>attrs</i>])

Generates a single model of type *type*, inserts it into the database (giving it an id), and returns the data that was
added.

```js
test("I can view a contact's details", function() {
  var contact = server.create('contact');

  visit('/contacts/' + contact.id);

  andThen(() => {
    equal( find('h1').text(), 'The contact is Link');
  });
});
```

You can override the attributes from the factory definition with a
hash passed in as the second parameter. For example, if we had this factory

```js
export default Factory.extend({
  name: 'Link'
});
```

we could override the name like this:

```js
test("I can view the contacts", function() {
  server.create('contact', {name: 'Zelda'});

  visit('/');

  andThen(() => {
    equal( find('p').text(), 'Zelda' );
  });
});
```

<a name="createList" href="#createList">#</a> server.<b>createList</b>(<i>type</i>, <i>amount</i> [, <i>attrs</i>])

Creates *amount* models of type *type*, optionally overriding the attributes from the factory with *attrs*.

Returns the array of records that were added to the database.

Here's an example from a test:

```js
test("I can view the contacts", function() {
  server.createList('contact', 5);
  var youngContacts = server.createList('contact', 5, {age: 15});

  visit('/');

  andThen(function() {
    equal(currentRouteName(), 'index');
    equal( find('p').length, 10 );
  });
});
```

And one from setting up your development database:

```js
// mirage/scenarios/default.js
export default function(server) {
  var contact = server.create('contact');
  server.createList('address', 5, {contactId: contact.id});
}
```
