<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Mirage 0.2.0-beta.9 released &middot; Ember CLI Mirage
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/style.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <div class="Topbar">
      <div class="Container">
      </div>
    </div>

    <header class="Header">
  <div class="Container">
    <nav class='Header__nav'>
      <ul class='Header__nav-list'>
        <li class='Header__nav-item'>
          <a href='/docs/v0.4.x' class="Header__nav-item-link">
            <span class="u-mobile">Docs</span>
            <span class="u-desktop">Documentation</span>
          </a>
        </li>
        <li class='Header__nav-item'>
          <a href='/blog' class="Header__nav-item-link active">Blog</a>
        </li>
        <li class='Header__nav-item'>
          <a href='/about' class="Header__nav-item-link">About</a>
        </li>
        <li class='Header__nav-item'>
          <a href="https://github.com/samselikoff/ember-cli-mirage" class='Header__nav-item-link' target="_blank">GitHub</a>
        </li>
      </ul>
    </nav>
    <a class="Header__logo" href="/">
      <span class='Header__logo-minor'>Ember CLI</span><br>
      <span class='Header__logo-major'>Mirage</span>
    </a>
  </div>
</header>


    <div class="Wrapper">
      <div class="Content">
        <div class="Blog">
  <div class='Blog__post'>
    <div class="Blog__post-info">
      <h1 class='Blog__title'>Mirage 0.2.0-beta.9 released</h1>
      <p class='Blog__byline'>May 13, 2016</p>
      <hr class='Blog__divider'>
    </div>
    <div class='Blog__content'>
      <p>Mirage v0.2.0-beta.9 has been released. Check out <a href="https://github.com/samselikoff/ember-cli-mirage/releases/tag/v0.2.0-beta.9">the release notes</a> for the breaking changes and enhancements.</p>

<h2 id="update-on-a-02-stable-release">Update on a 0.2 stable release</h2>

<p>I wanted to jot down some of my recent thoughts while putting this release together. Pardon the rambling.</p>

<p>Originally I had planned for beta.9 to be the last beta release before cutting 0.2. Since folks have started using the 0.2 beta series, however, pain points around data modeling have been cropping up. In particular, dealing with <code class="highlighter-rouge">has-one</code> and <code class="highlighter-rouge">many-to-many</code> associations is quite difficult with the current set of abstractions.</p>

<p>My first thought was to ship 0.2 as is, and then work on adding helpers for <code class="highlighter-rouge">hasAndBelongsToMany</code> and <code class="highlighter-rouge">hasOne</code>. After some more thought &amp; discussions with various users, I realized that the ORM’s abstractions might be a touch off. Let me explain.</p>

<p>Mirage’s ORM was built to support features like JSON:API includes and the planned factory relationships. The ORM is a way to encode association information, since there was no good place to do this in <code class="highlighter-rouge">v0.1</code>. My approach was to largely mimic server-side frameworks like Rails, since they’ve already solved this problem. After all, your models already live on the backend in database tables, so why not use the same concepts? Tables with foreign keys are familiar to backend devs, so let’s just emulate those concepts in Mirage.</p>

<p>So, that’s been the plan so far. The ORM has working <code class="highlighter-rouge">hasMany</code> and <code class="highlighter-rouge">belongsTo</code> associations, and those take care of many cases. The <code class="highlighter-rouge">manyToMany</code> case is interesting, though, because there’s not necessarily a standard conventional way that all Ember developers or servers approach this problem.</p>

<p>Take a simple <code class="highlighter-rouge">belongsTo</code>, like a <code class="highlighter-rouge">post</code> that belongs to an <code class="highlighter-rouge">author</code>. The <code class="highlighter-rouge">post</code> probably owns the foreign key, something like <code class="highlighter-rouge">author_id</code>. Persisting this relationship, then, is as simple as saving any other attribute on the <code class="highlighter-rouge">post</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PUT /api/posts/1

{
  post: {
    id: 1,
    title: 'Hipster ipsum',
    author_id: 24
  }
}
</code></pre></div></div>

<p><code class="highlighter-rouge">author_id</code> is all that’s needed to tell both Ember Data and the server about the new relationship.</p>

<p><code class="highlighter-rouge">hasMany</code> is where things start to get tricky. Let’s assume we’ve also defined the inverse of the above relationship, so an <code class="highlighter-rouge">author</code> has many <code class="highlighter-rouge">posts</code>. If you updated an author with new posts, how would you persist those new relationships?</p>

<p>As above, the foreign key on each <code class="highlighter-rouge">post</code> is all that’s needed to tell both the frontend and the backend about the new relationship, so typically I would handle it like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">post1</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="s1">'author'</span><span class="p">,</span> <span class="nx">author</span><span class="p">);</span>
<span class="nx">post1</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>

<span class="nx">post2</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="s1">'author'</span><span class="p">,</span> <span class="nx">author</span><span class="p">);</span>
<span class="nx">post2</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>
</code></pre></div></div>

<p>and so on. You can write code that batches these requests, but the point here is that this is pretty straightforward stuff. Persisting a relationship is just boring old CRUD on a resource.</p>

<p>Interestingly, the <a href="https://guides.emberjs.com/v2.5.0/models/relationships/#toc_creating-records">Ember Data guides</a> show code that suggests persisting a <code class="highlighter-rouge">hasMany</code> relationship by calling <code class="highlighter-rouge">save</code> on the parent, which looks something like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">author</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s1">'posts'</span><span class="p">).</span><span class="nx">pushObjects</span><span class="p">([</span><span class="nx">post1</span><span class="p">,</span> <span class="nx">post3</span><span class="p">]);</span>
<span class="nx">author</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>
</code></pre></div></div>

<p>Now, Ember Data can understand this, and in fact this is how some teams work. But what does the request/response look like? Maybe something like</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PUT /authors/1
{
  author: {
    id: 1,
    name: 'Frank',
    post_ids: [1, 3]
  }
}
</code></pre></div></div>

<p>This is a request to update a single <code class="highlighter-rouge">author</code> resource - but behind the scenes, is your backend actually updating the foreign keys on two different post records? If so, we’ve kind of moved out of the realm of doing boring CRUD on resources, because now our server is doing something different or more than what we asked of it: we asked it to update the <code class="highlighter-rouge">author:1</code> resource, and in reality it’s updating two other <code class="highlighter-rouge">post</code> resources. Interestingly I’ve asked several folks in the community how they deal with this issue, and the response varies.</p>

<p>The story gets even trickier with many-to-many relationships. Sometimes people model the join record in their Ember apps, sometimes they don’t. If they don’t, a PUT to an <code class="highlighter-rouge">author</code> resource could actually be <em>creating</em> multiple server resources behind the scenes, via a join table.</p>

<p>This obviously has implications for Mirage, which works best with conventional server endpoints. A PUT to a resource updates that resource, and so on. But plenty of people write their servers this way, and it got me thinking: perhaps database tables and foreign keys are the wrong abstraction for Mirage to emulate. Perhaps transport of HTTP resources is a bit more generic and abstract than that.</p>

<p>Take, for example, the following Ember Data model definitions:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// models/post.js</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

  <span class="na">categories</span><span class="p">:</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">hasMany</span><span class="p">();</span>

<span class="p">});</span>

<span class="c1">// models/category.js</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

  <span class="na">name</span><span class="p">:</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">attr</span><span class="p">()</span>

<span class="p">});</span>
</code></pre></div></div>

<p>That is a perfectly valid and legitimate domain model. By looking at those two models, can you tell me which entity owns the foreign key? Nope. In fact, you don’t even know if this is a one-to-many or many-to-many relationship. And yet, from the perspective of HTTP resources (including a valid implementation of a JSON:API server), this is totally valid.</p>

<p>Here’s the JSON:API response, for example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /posts/1?include=categories

{
  data: {
    type: 'posts',
    id: 1,
    relationships: {
      categories: [
        {
          data: {
            type: 'categories',
            id: '2'
          }
        },
        {
          data: {
            type: 'categories',
            id: '5'
          }
        }
      ]
    }
  },
  included: [
    {
      type: 'categories',
      id: '2',
      attributes: {
        name: 'Economics'
      }
    },
    {
      type: 'categories',
      id: '5',
      attributes: {
        name: 'Programming'
      }
    }
  ]
}
</code></pre></div></div>

<p>Totally valid, and also impossible to ascertain whether this is a one-to-many or many-to-many relationship.</p>

<p>Basing Mirage’s ORM on database tables and foreign keys makes some things really easy and familiar, but for these situations it’s a pain. If your actual Ember app and your actual server can handle a request like</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PUT /posts/1
{
  post: {
    id: 1,
    tag_ids: [1, 4]
  }
}
</code></pre></div></div>

<p>just fine, you shouldn’t have to add extra logic or models to make your fake Mirage server work.</p>

<p>The solution I have in mind for this problem is to replace the foreign key implementation with an associations map. This map will be a singleton that all models will have a reference to, and it will be used to persist model relationships.</p>

<p>The external API of Mirage’s ORM won’t change. For example, say you had a <code class="highlighter-rouge">author</code> that has many <code class="highlighter-rouge">posts</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// mirage/models/author.js</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="na">posts</span><span class="p">:</span> <span class="nx">hasMany</span><span class="p">()</span>
<span class="p">});</span>

<span class="c1">// mirage/models/post.js</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Currently (in 0.2.0-beta.9), Mirage makes an assumption here that the <code class="highlighter-rouge">post</code> resource has an <code class="highlighter-rouge">author_id</code> foreign key. As we’ve just shown, this is potentially a false assumption. My previous plan was to write a <code class="highlighter-rouge">hasAndBelongsToMany</code> helper for many-to-many relationships. Then, if this relationship turned out to be a many-to-many, the user would need to do something like the following:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// mirage/models/author.js</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="na">posts</span><span class="p">:</span> <span class="nx">hasAndBelongsToMany</span><span class="p">()</span>
<span class="p">});</span>
</code></pre></div></div>

<p>This would tell Mirage to transparently create a <code class="highlighter-rouge">author-post</code> join table, and deal with the persistence there.</p>

<p>Again, this now feels like the wrong abstraction, and it also introduces concepts that aren’t necessarily appropriate for the domain of the frontend. Instead, the original domain model with the <code class="highlighter-rouge">hasMany</code> declaration will add an <code class="highlighter-rouge">author.posts</code> key to the singleton associations map, where all the relationship data can be stored. This has an added benefit of simplifying Mirage’s interface for creating relationships in factories and elsewhere, as now developers will be able to do things like</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">author</span> <span class="o">=</span> <span class="nx">server</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="s1">'author'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">categoryIds</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">});</span>
</code></pre></div></div>

<p>in their tests, similar to what they’re used to doing in Ember Data. We can also make Mirage’s shorthands understand both forms of saving <code class="highlighter-rouge">hasMany</code> relationships, since the ids on the models will just be pointers to the associations map. Serializers can be used to customize which ids are sent along with the response.</p>

<p>This change will also make it easier to ascertain all model information from an existing set of Ember Data models in the future. I’m confident the overall learning curve will be easier and resulting code will be cleaner.</p>

<p>While this will take a bit more time to get right, I think it’s important. I also feel like I have a better grasp of something important, namely that Mirage as an HTTP faking layer should not necessarily emulate various server abstractions, but rather focus on concepts that come from HTTP. It turns out that single-owner foreign keys is not one of those concepts, and therefore this abstraction does not belong in Mirage.</p>

<p>I’ll probably release 0.2, and work the associations map into a 0.3 release. Still thinking this through, though.</p>

<p>My closing thought is that these HTTP concepts are crucial to understand if you’re going to write an Ember app, and they can’t just be left to the backend team. It’s true that a frontend developer doesn’t need to know that Rails has a <code class="highlighter-rouge">has_and_belongs_to_many</code> method that abstracts away join tables on many-to-many relationships; however, the developer does need to understand how her Ember app will retrieve and persist many-to-many relationships across the network. Domain modeling and HTTP transport is a central part of Ember development and unfortunately at the moment, many parts of it are still non-standard and unconventional.</p>

      
      <div id="disqus_thread"></div>
    </div>
  </div>
</div>


<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//emberclimirage.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

      </div>
    </div>

    <footer class="Footer">
  <div class="Container Grid Grid--gutters Grid--full med-Grid--fit">
    <div class="Grid-cell">
      <p>Project and site maintained by <a href="https://twitter.com/samselikoff">Sam Selikoff</a> and <a href="https://github.com/samselikoff/ember-cli-mirage/graphs/contributors">contributors</a>.</p>
      <p>Sponsored by <a href="https://embermap.com/">EmberMap</a>.<p>
    </div>
    <div class="Grid-cell">
      <div class="Github-stars">
        <iframe src="https://ghbtns.com/github-btn.html?user=samselikoff&repo=ember-cli-mirage&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js"></script>
<script>
  /* global anchors */
  // anchors.options = {
  //   placement: 'left',
  //   visible: 'always'
  // };
  anchors.add('h2:not(.Home-page__feature-heading)');
</script>


  </body>
</html>
